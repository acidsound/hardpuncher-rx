// Generated by CoffeeScript 1.10.0
(function() {
  var $;

  $ = function(e) {
    return document.getElementById(e);
  };

  Rx.Observable.fromEvent(document, 'DOMContentLoaded').subscribe(function() {
    var enemyAttackStream, enemyHitAnim, enemyState, enemySubject, logSubject, punchState, punchSubject;
    console.log("PPOOOM");

    /* 1. 전투 기록 */
    logSubject = new Rx.BehaviorSubject('적이 나타났다!');
    logSubject.subscribe(function(o) {
      var logArea;
      logArea = $('log');
      return logArea.innerText = o + "\n" + logArea.innerText;
    });

    /* 2. 적 subject */
    enemySubject = new Rx.Subject;
    enemyHitAnim = function(o) {

      /* 피격 Animation */
      var effect;
      effect = {
        'hit': function() {
          return TweenMax.to($('enemy'), 0.05, {
            top: '1rem',
            yoyo: true,
            repeat: 3
          });
        },
        'CRITICAL!': function() {
          return TweenMax.to(document.querySelector('.틀'), 0.05, {
            css: {
              scale: 1.3,
              rotation: 5
            },
            yoyo: true,
            repeat: 3
          });
        }
      };
      effect[o.lastAttack.action]();
      return logSubject.next(o.lastAttack.action + " 데미지" + o.lastAttack.damage + "! HP: " + o.hp);
    };
    enemyState = Rx.Observable.of({
      hp: 200
    }).merge(enemySubject).scan(function(p, n) {
      return Object.assign(p, {
        hp: p.hp - n.damage,
        lastAttack: n
      });
    }).filter(function(o) {
      return o.lastAttack;
    });
    enemyState.subscribe(function(o) {
      return enemyHitAnim(o);
    });

    /* 3. 주먹 subject */
    punchSubject = new Rx.BehaviorSubject('ready');
    punchSubject.filter(function(o) {
      return o === 'ready';
    }).subscribe(function() {});
    punchSubject.filter(function(o) {
      return o === 'punch';
    }).subscribe(function() {
      return TweenLite.fromTo($('punch'), 0.3, {
        left: '2rem'
      }, {
        left: '76%',
        ease: Power4.easeIn,
        onComplete: function() {
          return punchSubject.next('crash');
        }
      });
    });
    punchSubject.filter(function(o) {
      return o === 'crash';
    }).subscribe(function() {
      var anim, calcDamage;
      anim = {
        step1: function() {
          return TweenMax.to($('punch'), 0.05, {
            top: '1rem',
            yoyo: true,
            repeat: 3,
            onComplete: (function(_this) {
              return function() {
                return _this.step2();
              };
            })(this)
          });
        },
        step2: function() {
          return TweenLite.fromTo($('punch'), 0.05, {
            left: '76%'
          }, {
            left: '2rem',
            ease: Power4.easeIn,
            onComplete: function() {
              return punchSubject.next('ready');
            }
          });
        }
      };
      anim.step1();

      /* 적 힛트!! */
      calcDamage = function() {
        if ((~~(~~(Math.random() * 11) / 10)) < 1) {
          return {
            action: 'hit',
            damage: 10
          };
        } else {
          return {
            action: 'CRITICAL!',
            damage: 50
          };
        }
      };
      return enemySubject.next(calcDamage());
    });
    punchState = punchSubject.filter(function(o) {
      return o === 'hitted';
    });
    punchState.subscribe(function(o) {
      return TweenMax.to($('stage'), 0.05, {
        left: '0.5rem',
        yoyo: true,
        repeat: 3,
        onComplete: function() {
          return punchSubject.next('ready');
        }
      });
    });
    new Rx.Observable.of(2000).merge(punchState.map(function(o) {
      return 100;
    })).scan(function(p, n) {
      return p - n;
    }).subscribe(function(o) {
      return console.log("HP: " + o);
    });

    /* 5. 공격 클릭 스트림 */
    ['mousedown', 'touchstart'].map(function(v) {
      var checkReadyStream, clickStream;
      clickStream = Rx.Observable.fromEvent($('fire'), v);

      /* 중복 공격 방지. punchSubject의 마지막 상태가 ready(r) 일때만 filter 한다.
         punchSubject : r - p c r - p c r - p c r (r:ready, p: punch, c: crash)
         clickStream  : - c - c - c c - - c - - -
         sample       : - r - c - r p - - r - - - (take only punchSubject)
         filter ===r  : - r - - - r - - - r - - -
       */
      checkReadyStream = punchSubject.sample(clickStream).filter(function(o) {
        return o === 'ready';
      });
      return checkReadyStream.subscribe(function(o) {
        return punchSubject.next('punch');
      });
    });
    return enemyAttackStream = Rx.Observable.interval(4000).subscribe(function(o) {
      return punchSubject.next('hitted');
    });
  });

}).call(this);
